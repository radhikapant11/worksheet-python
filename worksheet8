import math

EPS = 1e-12

# ---- Point class and utilities (Q1 + Q3 + Q4) ----
class Point:
    def __init__(self, x, y):
        self.x = float(x)
        self.y = float(y)

    def __repr__(self):
        return f"Point({self.x:.6g}, {self.y:.6g})"

def distance(A: Point, B: Point) -> float:
    return math.hypot(B.x - A.x, B.y - A.y)

def midpoint(A: Point, B: Point) -> Point:
    return Point((A.x + B.x) / 2.0, (A.y + B.y) / 2.0)

def line_equation(A: Point, B: Point):
    # returns (m, c) for y = m x + c, or (None, x_const) for vertical line x = x_const
    if abs(A.x - B.x) < EPS:
        return None, A.x
    m = (B.y - A.y) / (B.x - A.x)
    c = A.y - m * A.x
    return m, c

def reflect_point_over_line(A: Point, B: Point, C: Point) -> Point:
    # reflect C across line AB. If A==B, reflect C across point A.
    vx = B.x - A.x
    vy = B.y - A.y
    v2 = vx*vx + vy*vy
    if v2 < EPS:
        return Point(2*A.x - C.x, 2*A.y - C.y)
    wx = C.x - A.x
    wy = C.y - A.y
    t = (wx*vx + wy*vy) / v2
    px = A.x + t * vx
    py = A.y + t * vy
    rx = 2*px - C.x
    ry = 2*py - C.y
    return Point(rx, ry)

# Segment utilities (Q3)
def segment_length(S: Point, E: Point) -> float:
    return distance(S, E)

def closest_point_on_segment(S: Point, E: Point, P: Point) -> Point:
    vx = E.x - S.x
    vy = E.y - S.y
    seg_len_sq = vx*vx + vy*vy
    if seg_len_sq < EPS:
        return Point(S.x, S.y)
    t = ((P.x - S.x) * vx + (P.y - S.y) * vy) / seg_len_sq
    t = max(0.0, min(1.0, t))
    return Point(S.x + t * vx, S.y + t * vy)

def distance_point_to_segment(S: Point, E: Point, P: Point) -> float:
    C = closest_point_on_segment(S, E, P)
    return distance(P, C)

# Line intersection (Q4)
def intersect_lines(a1, b1, c1, a2, b2, c2):
    det = a1*b2 - a2*b1
    if abs(det) < EPS:
        return None
    x = (c1*b2 - c2*b1) / det
    y = (a1*c2 - a2*c1) / det
    return Point(x, y)

# ---- Vector class and utilities (Q2) ----
class Vector:
    def __init__(self, x, y):
        self.x = float(x)
        self.y = float(y)

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)

    def __mul__(self, scalar: float):
        return Vector(self.x * scalar, self.y * scalar)

    def dot(self, other) -> float:
        return self.x * other.x + self.y * other.y

    def magnitude(self) -> float:
        return math.hypot(self.x, self.y)

    def angle_with(self, other):
        mag1 = self.magnitude()
        mag2 = other.magnitude()
        if mag1 < EPS or mag2 < EPS:
            return None
        cos_theta = self.dot(other) / (mag1 * mag2)
        cos_theta = max(-1.0, min(1.0, cos_theta))
        return math.degrees(math.acos(cos_theta))

    def projection_onto(self, other):
        denom = other.dot(other)
        if denom < EPS:
            return None
        factor = self.dot(other) / denom
        return other * factor

    def as_tuple(self):
        return (self.x, self.y)

    def __repr__(self):
        return f"Vector({self.x:.6g}, {self.y:.6g})"

# ---- Combined demo function showing all questions ----
def demo():
    print("=== QUESTION 1 (Points & Line) ===")
    A = Point(1, 2)
    B = Point(4, 6)
    C = Point(3, 5)  # for reflection
    print("A =", A)
    print("B =", B)
    print("Distance A-B:", distance(A, B))
    print("Midpoint A-B:", midpoint(A, B))
    m, c_or_x = line_equation(A, B)
    if m is None:
        print(f"Line AB is vertical: x = {c_or_x:.6g}")
    else:
        print(f"Line AB: y = {m:.6g}x + {c_or_x:.6g}")
    print("Reflection of C across AB:", reflect_point_over_line(A, B, C))

    print("\n=== QUESTION 2 (Vectors) ===")
    vA = Vector(2, -1)
    vB = Vector(1, 3)
    vC = Vector(-4, 2)
    print("A =", vA)
    print("B =", vB)
    print("C =", vC)
    R = vA + vB + vC
    print("2.1 Resultant R = A + B + C =", R)
    print("2.2 Magnitudes: |A|=%.6g, |B|=%.6g, |C|=%.6g" % (vA.magnitude(), vB.magnitude(), vC.magnitude()))
    print("2.3 Dot products: A·B=%.6g, A·C=%.6g, B·C=%.6g" % (vA.dot(vB), vA.dot(vC), vB.dot(vC)))
    angAB = vA.angle_with(vB)
    angAC = vA.angle_with(vC)
    angBC = vB.angle_with(vC)
    print("2.4 Angles (deg): angle(A,B)=%s, angle(A,C)=%s, angle(B,C)=%s" %
          (f"{angAB:.6g}" if angAB is not None else "undefined",
           f"{angAC:.6g}" if angAC is not None else "undefined",
           f"{angBC:.6g}" if angBC is not None else "undefined"))
    projA_on_B = vA.projection_onto(vB)
    print("2.5 Projection of A onto B =", projA_on_B if projA_on_B is not None else "undefined")

    print("\n=== QUESTION 3 (Segment & Point) ===")
    S = Point(0, 0)
    E = Point(5, 0)
    P = Point(3, 4)
    print("S =", S, "E =", E, "P =", P)
    print("3.1 Segment length SE =", segment_length(S, E))
    Cpt = closest_point_on_segment(S, E, P)
    print("3.2 Closest point on SE to P =", Cpt)
    print("3.3 Distance from P to segment =", distance_point_to_segment(S, E, P))

    print("\n=== QUESTION 4 (Line Intersection) ===")
    # Example: x - y = 0  and  y = 2
    a1, b1, c1 = 1, -1, 0
    a2, b2, c2 = 0, 1, 2
    inter = intersect_lines(a1, b1, c1, a2, b2, c2)
    if inter is None:
        print("Lines are parallel or coincident.")
    else:
        print("Intersection point:", inter)

if __name__ == "__main__":
    demo()
